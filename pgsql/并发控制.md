# 并发控制

当数据库中有多个事务并发执行时，事务的隔离性不一定能保持，为保持事务的隔离性。系统必须对并发事务之间的相互作用加以控制，通过**并发控制机制**实现。

## 基于锁的协议
### 锁
这里只考虑两种锁：

* 共享的：如果事务T获取了数据项Q上的共享锁（S锁），则事务T可读不可写Q。
* 排他的：如果事务T获取了数据项Q上的排他锁（X锁），则事务T即可读也可写。

这两种锁类型的使用可以让多个事务读取一个数据项但是强制限制同时只能有一个事务进行写操作。

定义一个相容函数：令A和B代表任意的锁类型，假设事务T1请求数据项Q加A类型锁，而事务T2当前在数据项Q上拥有B类型锁。尽管数据项Q上存在B类型锁，如果事务T1可以立即获得数据项Q上的锁，那么A类型锁和B类型锁时相容的。相容矩阵如下表：

|     |   S   |   X   |
| --- | ----- | ----- |
| S   | true  | false |
| X   | false | false |

在任何时候，一个数据项可同时有多个共享锁。此后的排他锁请求必须一致等待直到该数据项上的所有共享锁被释放。

一般而言，如果为了避免不一致状态而采取封锁，则死锁是随之而来的必然你产物。产生死锁显示比产生不一致状态要好，因为死锁可以通过回滚事务解决，而不一致状态可能引起现实中的问题，数据库系统不能处理。

要求在系统中每一个事务遵从称为**封锁协议**的一组规则，这些规则规定事务何时对数据项进行加锁、解锁。

### 锁的授予
考虑这样一种情况：事务T1持有数据项的共享锁，事务T2请求该数据项的排他锁，这时事务T2必须等待事务T1释放共享锁，但在T1释放共享锁之前，事务T3也请求该数据项的共享锁，因为锁是相容的，所以事务T3获得了该数据项的共享锁，如此一直下去，事务T2永远获取不到该数据项的排他锁，这种情况称为**饿死**。

可以通过按如下方式授权加锁来避免事务饿死：当事务T1申请对数据项Q加M型锁时，并发控制管理器授权加锁的条件是：

* 不存在该数据项Q上持有与M型锁冲突的锁的其他事务。
* 不存在等待该数据项Q加锁且先于T1申请加锁的事务。

因此，一个加锁请求就不会被其后的加锁申请阻塞。

### 两阶段封锁协议
保证可串行化的一个协议是**两阶段封锁协议**。该协议要求每个事务分两个阶段提出加锁和加锁申请：

* 增长阶段：事务可以获得锁，但不能释放锁。
* 缩减阶段：事务可以释放锁，但不能获得新锁。

如以下事务T3：

```
lock-X(B);
read(B);
B := B - 50;
write(B);
lock-X(A);
read(A);
A := A + 50;
write(A);
unlock(B);
unlock(A);
```

解锁指令不必非得出现在事务末尾。例如上面事务T3，可以把`unlock(B)`指令放在紧跟指令`lock-X(A)`之后。

可以证明两阶段封锁协议保证冲突可串行化。对于任何事务，在调度中该事务获取其最后加锁的位置（增加阶段结束点）称为事务的**封锁点**。这样，多个事务可以根据它们的封锁点进行排序，实际上，这个顺序就是事务的一个可串行化顺序。

两阶段封锁并不保证不会发生死锁。如下调度：

```
|     T3    |     T4     |
| lock-X(B) |            |
| read(B)   |            |
| B := B-50 |            |
|           | lock-S(A)  |
|           | read(A)    |
|           | lock-S(B)  |
| lock-X(A) |            |
```


## 死锁处理
如果存在一个事务集，该集合中的每个事务在等待该集合的另一个事务，那么系统处于**死锁**状态。

此时，系统的唯一补救措施是采取激烈的工作，如回滚某些陷于死锁的事务。事务有可能只部分回滚，即事务回滚到这样的点之前，它在该点得到一个锁，而释放锁就可以解决死锁。

处理死锁问题有两种主要方法：

* 死锁预防：死锁预防协议保证系统永不进入死锁状态。
* 死锁检测和死锁恢复

两种方法都有可能引起事务回滚。如果系统进入死锁状态的概率相对较高，则通常使用死锁预防；否则，使用检测与恢复机制会更有效。

### 死锁预防
预防死锁有两种方法：

* 通过对加锁请求进行排序或要求同时获得所有的锁保证不会发生循环等待。
* 每当等待有可能导致死锁时，进行事务回滚而不是等待加锁。

第一种方法下最简单的机制要求每个事务在开始之前封锁它的所有数据项。此外，要么一次全部封锁要么全不封锁。这个协议有两个主要缺点：

* 在事务开始前通常很难预知哪些数据项需要封锁。
* 数据项使用率可能很低，因为很多数据项可能封锁很长时间却用不到。

防止死锁的另一种机制是对所有的数据项强加一个次序，同时要求事务只能按次序规定的顺序封锁数据项。

第二种方法是使用抢占与事务回滚。

### 死锁检测与恢复
为了实现死锁检测与恢复，系统必须：

* 维护当前将数据项分配给事务的有关信息，以及任何尚未解决的数据项的请求信息。
* 提供一个使用这些信息判断系统是否进入死锁状态的算法。
* 当检测算法判定存在死锁时，从死锁中恢复。

#### 死锁检测
死锁可以通过称为**等待图**的有向图来精确描述。如果等待图无环，则系统没有处于死锁状态。

#### 从死锁中恢复
解除死锁最通常的做法是回滚一个或多个事务。需采取的动作有三个：

* 选择牺牲者：选择最小代价的牺牲者。
* 回滚：可以彻底回滚和部分回滚。
* 饿死：有可能同一事务总是被选为牺牲者，这样就会发生饿死。


## 多粒度
具体参考数据库系统概念


## 多版本机制
在多版本并发控制机制中，每个`write(Q)`操作创建Q的一个新版本。当事务发出一个`read(Q)`操作时，并发控制管理器选择Q的一个版本进行读取。并发控制机制必须保证用于读取的版本的选择能保持可串行性。

### 多版本时间戳排序
参考书籍

### 多版本两阶段封锁
多版本两阶段封锁协议将多版本并发控制的优点与两阶段封锁的优点结合。该协议对**只读事务**与**更新事务**区分。

更新事务执行强两阶段封锁协议：即它们持有全部锁直到事务结束。因此，它们可以按提交的次序进行串行化。数据库的每个版本有一个时间戳，这种时间戳不是真正基于时钟的时间戳，而是一个计数器，称为**ts-counter**，这个计算器在提交处理时增加计数。

只读事务在开始执行前，数据库系统读取ts-counter的当前值来作为该事务的时间戳。


## 快照隔离
参考书籍