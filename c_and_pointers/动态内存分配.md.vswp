vnote_backup_file_826537664 E:/notebook/c_and_pointers/动态内存分配.md
# 动态内存分配

当一个数组被声明时，它所需要的内存在编译时就被分配。但是，也可以使用动态内存分配在运行时为它分配内存。

## 为什么使用动态内存分配
在声明数组时，必须用一个编译时常量指定数组长度。但是，数组的长度常常在运行时才知道。如果采用声明一个较大的数组来解决，那么有以下缺点：
* 这种声明在程序中引入了人为的限制，如果需要的长度超过声明的长度，无法处理。
* 如果程序实际上需要较少的元素，巨型数组的绝大部分内存空间都被浪费了。
* 如果输入的数据超过了数组的容纳范围，程序必须以一种合理的方式作出响应。它不应该由于一个异常而失败。


## malloc和free
`void *malloc(size_t size);`
获取size个字节的动态内存（位于堆上），返回一个指向被分配的内存块起始地址的指针。如果失败，返回一个NULL指针。在unix中，底层实际上调用brk或mmap系统调用。malloc所返回的内存的起始位置将始终能够满足对边界要求最严格的类型要求。**malloc所分配的是一块连续的内存。**

`void free(void *pointer);`
free的参数必须是NULL或者是一个先前从malloc、calloc或realloc返回的指针。向free传递一个NULL参数不会产生任何效果。


## calloc和realloc
`void *calloc(size_t num_elements, size_t element_size);`
malloc和calloc之间的主要区别是后者在返回这项内存的指针之前把它初始化为0。参数分别是所需元素的数量和每个元素的字节数。

`void *realloc(void *ptr, size_t new_size);`
realloc函数用于修改一个原先已经分配的内存块的大小。如果它用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，新内存并未以任何方式进行初始化。如果它用于缩小一个内存块，该内存块尾部的部分内存便被删除，剩余部分内存依然保持原样。

**如果原来的内存块无法改变大小，realloc将分配另一块正确大小的内存，并把原来那块内存的内容复制到新的块上。**

**如果realloc函数的第1个参数是NULL，则它的作用和malloc一样。**


## 常见的动态内存错误
* 对NULL指针进行解引用操作。
* 对分配的内存进行操作时越过边界。
* 释放并非动态分配的内存。
* 试图释放一块动态分配内存的一部分以及一块动态内存被释放后被继续使用。
* 忘记检查所请求的内存是否分配成功。


## 总结
当数组被声明时，必须在编译时知道它的长度。动态内存分配允许程序为一个长度在运行时才确定的数组分配内存空间。

如果一个指针不是从malloc、calloc或realloc函数返回的，它不能作为参数传递给free函数。而且，也不能释放一块内存的一部分，但可以通过realloc间接释放一部分内存。

内存泄露是指内存被动态分配以后，当它不再使用时未被释放。内存泄露会增加程序的体积，有可能导致程序或系统崩溃。