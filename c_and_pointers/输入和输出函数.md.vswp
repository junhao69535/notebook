vnote_backup_file_826537664 E:/notebook/c_and_pointers/输入和输出函数.md
# 输入和输出函数

## 错误报告
`void perror(char const *message);`
原型位于stdio.h。如果meesage不是NULL并且指向一个非空的字符串，perror函数就打印出这个字符出啊你，后面跟一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息。

**注意，只有当一个库函数失败时，errno才会被设置。当函数成功运行时，errno的值不会被修改。这意味着我们不能通过测试errno的值判断是否有错误发生。反之，只有当被调用的函数提示有错误发生时检查errno的值才有意义。

## 终止运行
`void exit(int status);`
原型位于stdlib.h。status参数返回给操作系统，用于提示程序是否正常完成。这个值和main函数返回的整型状态值相同。

## 标准I/O函数库
这个函数库存在两个主要的缺陷：
* 它是在某台特定类型的机器上实现的，并没有对其他具有不同特性的机器作过多的考虑。移植性差。
* 想修复第一个缺点需要修改库函数，但这会使函数库不再“标准”，程序的可移植性就会降低。

ANSI C函数库中的I/O函数是旧式标准I/O库函数的直接后代，只是这些ANSI版函数作了可移植性和完整性的改进。ANSI C的一个主要优点就是这些修改将通过增加不同函数的方式实现，而不是通过对现存函数进行修改实现。程序的可移植性不会受到影响。

## ANSI I/O概念
头文件stdio.h包含了与ANSI函数库的I/O部分有关的声明，它的名字来源于旧式标准I/O函数库。尽管不包含这个头文件也可以使用某些I/O函数，但绝大部分I/O函数的声明都在这个头文件。

### 流
操作系统负责对不同I/O设备的通信细节，并向程序员提供了一个更为简单和统一的I/O接口。

ANSI C进一步对I/O的概念进行抽象。对C而言，所有的I/O操作只是简单地从程序移进或移出字节。因此，这种字节流便被称为流。个人认为，流就是一个和I/O设备交流的数据结构，如文本流，就以文本形式和I/O设备交流。流是一种抽象。

绝大多数流是完全缓冲的，这意味着“读取”和“写入”实际上是从一块被称为缓冲区的内存区域来回复制数据。用于输出流的缓冲区只有当它写满时才会刷新（也可以强制刷新）到设备或文件中。一次性把写满的缓冲区写入和逐片把程序所产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重写填充缓冲区。

#### 文本流
流分两种类型，文本流和二进制流。文本流的有些特性在不同的系统中可能不同，其中之一就是文本行的最大长度。标准规定至允许254个字符。另一个可能不同的特性时文本行的结束方式，在MS-DOS系统，文本文件约定以一个回车符(''r')和一个换行符('\n')结尾。而Unix系统只是用一个换行符('\n')结尾。库函数向我们隐藏了这些细节，它们会处理好这些细节。

#### 二进制流
二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且完全根据它们从文件或设别读取的形式读入程序中。

### 文件
stdio.h所包含的声明之一就是FILE结构。这是一个数据结构，用于访问一个流。

对于每个ANSI C程序，运行时系统必须提供至少三个流：标准输入、标准输出和标准错误。这些流的名字分别为stdin、stdout、stderr，它们都是在一个指向FILE结构的指针。

### 标准I/O常量
* EOF表示文件尾。
* FOPEN_MAX表示一个程序最多能打开多少个文件。这个值和编译器有关。
* FILENAME_MAX表示编译器支持文件名的最大长度。

## 流I/O总览
文件I/O的一般概况
1. 程序为必须同时处于活动状态的每个文件声明一个指针标量，其类型为FILE *。这个指针指向这个FILE结构，当它储与活动状态时由流使用。
2. 流通过调用fopen函数打开。为了打开一个流，你必须指定需要访问的文件或设备以及它们的访问方式（读、写或读写）。fopen和操作系统验证文件或设备确实存在并初始化FILE结构。
3. 然后，根据需要对该文件进行读取和写入。
4. 最后，调用fclose函数关闭流。关闭一个流可以防止与它相关联的文件被再次访问，保证任何存储于缓冲区的数据被正确地写到文件中，并且释放FILE结构使它可以用于另外的文件。

上面说的是文件流的基本处理。而标准流的I/O更为简单，因为它们不需要打开或关闭。

I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式，都由一组特定的函数对它们进行处理。下表列出了用于每种I/O形式的函数或函数家族。

执行字符、文本行和二进制I/O函数

|   数据类型    |       输入        |       输出        |            描述            |
| ------------- | ----------------- | ----------------- | ------------------------- |
| 字符          | getchar(函数家族） | putchar(函数家族） | 读取（写入）单个字符）      |
| 文本行        | gets(函数家族）    | puts(函数家族)     | 文本行未格式化的输入（输出） |
| 文本行（同上） | scanf(函数家族）   | printf(函数家族)   | 格式化的输入（输出）        |
| 二进制数据     | fread             | fwrite            | 读取（写入）二进制数据      |

函数家族指一组函数中的每个都执行相同的基本任务，只是方式稍有不同。这些函数的区别在于获得输入的来源或输出写入的地方不同，这些变种用于执行下面任务：
1. 只用于stdin或stdout
2. 随作为参数的流使用。
3. 使用内存中的字符串而不是流。

需要一个流参数的函数将接受stdin或stdout作为它的参数。有些函数家族并不具备用于字符串的各种函数，因为使用其他语句或函数来实现相同的结果更为容易。下面表列出每个家族的函数：

输入/输出函数家族

|  家族名  |   目的    | 可用于所有的流 | 只用于stdin和stdout | 内存中的字符串 |
| ------- | --------- | ------------- | ------------------ | ------------- |
| getchar | 字符输入   | fgetc,getc    | getchar            | ①             |
| putchar | 字符输出   | fputc,putc    | putchar            | ①             |
| gets    | 文本行输入 | fgets         | gets               | ②             |
| puts    | 文本行输出 | fputs         | puts               | ②             |
| scanf   | 格式化输入 | fscanf        | scanf              | sscanf        |
| printf  | 格式化输出 | fprintf       | printf             | sprintf       |

① 对指针使用下标引用或间接访问操作从内存获取一个字符（或向内存写入一个字符）。
② 使用strcpy函数从内存读取文本行（或向内存写入文本行）。

