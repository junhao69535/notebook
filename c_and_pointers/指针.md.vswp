vnote_backup_file_826537664 E:/notebook/c_and_pointers/指针.md
# 指针

## 内存和地址
尽管一个字包含4个字节，它仍然只有一个地址。至于地址是最左边那个字节的位置还是最右边的，不同的机器有不同的规定。
**边界对齐：在要求边界对齐的机器上，整型值存储的其实位置只能是某些特定的字节，通常是2或4的倍数**
但在C中，更关注的是：
* 内存中的每个位置由一个独一无二的地址标识。
* 内存中的每个位置都包含一个值。

**变量与内存位置之间的关联并不是硬件所提供的，它是由编译器为我们实现的。硬件仍然通过地址访问内存**


## 值和类型
**不能简单地通过检查一个值的位来判断它的类型**
如0110 0111 0110 1100 0110 1111 0110 0010，使用不同的数据格式和指令，对这些位的解释就不同：

|     类型     |       值       |
| ------------ | -------------- |
| 1个32位的整数 | 1735159650     |
| 2个16位整数   | 26476和28514   |
| 4个字符       | glob           |
| 浮点数        | 1.116533*10^24 |
| 机器指令 | beg.+110和ble.+102 |

**显然，值的类型并非值本身所固有的一种特性，而是取决于它的使用方式**


## 未初始化和非法指针

```c
int *a;
...
*a = 12;
```

声明一个指向整型的指针不会创建用于存储整型值的内存空间，只会创建存储该指针的内存空间(64位系统下指针需要8个字节内存空间)。

在Unix系统上，上面代码的错误被称为"段违例(segmentation violation)"或"内存错误(memory fault)"。它提示程序试图访问一个并未分配给程序的内存位置。

对于那些要求整数必须存储于特定边界的机器而言，如果这种类型的数据在内存中的存储地址处在错误的边界上，那么对这个地址进行访问时将会产生一个错误。这种错误在Unix系统中被称为"总线错误(bus error)"。


## NULL指针
标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。NULL指针用于表示某个特定的指针目前并未指向任何东西。如果不确定指针初始化为什么地址，则应该显式初始化为NULL指针。

**对一个NULL指针进行解引用操作是非法的，因此解引用一个指针前需要判断是否为NULL指针。**


## 总结
声明一个指针变量并不会自动分配任何内存。在对指针执行间接访问前，指针必须进行初始化：使它指向现有的内存或给它分配动态内存。对未初始化的指针变量执行间接访问操作时非法的。

NULL指针就是不指向任何东西的指针。对NULL指针执行间接访问操作的后果因编译器而异。

对指针执行间接访问操作所产生的值可能是右值，也可能是左值，因为这种表达式标识了一个特定的内存位置。

在极少见的情况下，我们偶尔需要使用指针常量，这是我们可以通过把一个整型值强制转换为指针类型来创建它。

对任何并非指向数组元素的指针执行算术运算是非法的。如果一个指针减去一个整数后，运算结果产生的指针所指向的位置在数组第一个元素之前，那么它也是非法的。加法运算稍有不同，如果结果指针指向数组最后一个元素后面的那个内存位置仍是合法（但不能对这个指针执行间接访问操作），不过再往后就不合法了。

如果两个指针不是指向同一个数组的元素，那么它们之间的减法操作是非法的。