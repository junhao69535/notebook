vnote_backup_file_826537664 E:/notebook/c_and_pointers/数据.md
# 数据

## 基本数据类型
在C语言中，只有四种数据类型：整型、浮点型、指针和聚合类型（数组和结构等）。

### 整型家族
整型家族包括字符、短整型、整型和长整型，它们都分别为有符号（signed）和无符号（unsigned）。

**长整型至少应该和整型一样长，而整型至少应该和短整型一样长。**

变量的最小范围

|   类型   | 最小范围 |
| ------- | ----------- |
| char | 0到127 |
| signed char | -127到127 |
| unsigned char | 0到255 |
| short int |  -32767到32767 |
| unsigned short int | 0 到65535 |
| int | -32767到32767 |
| unsigned int | 0到65535 |
| long int | -2147483647到2147483647 |
| unsigned long int | 0到4294967295 |

头文件limits.h说明了各种不同的证书类型的特点。它定义了各种常量用于表明变量的大小。

变量范围的限制

| signed | unsigned |
| ------- | ---------- |
| 类型 | 最小值-最大值 | 最大值 |
| 字符 | SCHAR_MIN-SCHAR_MAX | UCHAR_MAX |
| 短整型 | SHRT_MIN-SHRT_MAX | USHRT_MAX |
| 整型 | INT_MIN-INT_MAX | UINT_MAX |
| 长整型 | LONG_MIN-LONG_MAX | ULONG_MAX |

一、整型字面值
字面值即常量，这是一种实体，制定了自身的值，并且不允许发生改变。字面量要和用const声明的变量区分，const声明的变量是只读变量，初始化后值不能被改变，但其仍然是变量，不是常量。

在整数字面值后面添加字符L或l，可以使这个整数被解释为long整型值，字符U或u则用于把数值指定为unsigned整型值。如果ul一起给，则被解释为unsigned long整型值。

整数也可以用八进制表示，只要在数值前面以0开头；也可以用十六进制表示，以0x开头。这都是数值的表现形式，和数值的大小无关。

另外海有字符常量，它们的类型总是int。不能在后面添加u或l后缀。字符常量就是一个用单引号包围起来的单个字符（或字符转义序列或三字母词）如：'M'、'\n'（字符转义序列）、'??('（三字母词）、'\377'（以八进制表示的字符转义序列）。

如果一个多字节字符常量的前面有一个L，那么它表示宽字符常量。如：L'X'、L'e^'。当运行时环境支持一种宽字符集，就由可能使用它们。

二、枚举类型
枚举类型就是指它的值为符号常量而不是字面值的类型。它们以下面的形式声明：
enum Jar_Type {CUP, PINT, QUART, HALF_GALLON, GALLON};
这条语句声明了一个类型，称为Jar_Type。这种类型的变量按下列方式声明：
enum Jar_Type milk_jup, gas_can, medicine_bottle;
这种类型的变量实际上以整型的方式存储，这些符号名的实际值都是整型值。这里CUP是0，PINT是1，以此类推。也可以为这些符号名指定特定的整型值，如：
enum Jar_Type {CUP=8, PINT=16, QUART=32, HALF_GALLON=64, GALLON=128};
如果某个符号名未显式指定一个值，那么它的值就比前面一个符号名的值大1.

**符号名被当作整型常量处理，声明为枚举类型的变量实际上是整型类型**

### 浮点类型
浮点数家族包括float、double和long double类型。头文件float.h定义了名字FLT_MAX、DBL_MAX和LDBL_MAX，分别 表示float、double和long double所能存储的最大值。而FLT_MIN、DBL_MIN和LDBL_MIN分别表示float、double和long double能存储的最小值。

浮点数字面值在缺省的情况下都是double类型的，除非它的后面跟一个L或l表示它是一个long double类型的值，或者跟一个F或f表示它是一个float类型的值。

### 指针
指针即地址。指针变量就是其值为另外一个变量内存地址的变量。

一、指针常量
在c中，不存在这样的常量，不能书写一个类似0xff2044ec这样的字面值，因为我们不知道这是不是编译器实际上存放这个变量的内存地址。

二、字符串常量
个人认为叫字符串字面量更好。在c中，字符串的概念为：它就是一串以NUL字节结尾的零个或多个字符。字符串通常存储在字符数组中。由于NUL字节是用于中介字符串的，所以在字符串内部不能有NUL字节。即使是空字符串，以然存在作为终止符的NUL字节。

但是不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是这些字符本身。不过在字符数组定义是，初始化可以是字符串常量。


## 作用域
编译器可以确认四种不同类型的作用域：文件作用域、函数作用域、代码块作用域和原型作用域。

### 代码块作用域
位于一对花括号之间的所有语句称为一个代码块。由于两个代码块的变量不可能同时存在，所以编译器可以把它们存储于同一个内存地址。
在K&C中，如果函数体内部声明了名字与形参相同的局部变量，它们就将隐藏形参。但在ANSI C中把形参的作用域设定为函数最外层的那个作用域，即函数体内部不能定义和参数名字相同的变量。

### 文件作用域
任何在所有代码块之外声明的标识符都具有文件作用域

### 原型作用域
只适用于函数原型中声明的参数名。

### 函数作用域
这不是函数体内的作用域，只适用于语句标签，语句标签用于goto语句。


## 链接属性
有三个链接属性：external（外部）、internal（内部）和none（无）。
* none（无链接）：没有链接属性的标识符总被当作单独的个体，也就是说该标识符的多个声明被当作独立不同的实体。
* internal（内部链接）：属于内部链接属性的标识符在同一个源文件内的所有声明都指同一个实体。
* external（外部链接）：属于外部链接属性的标识符不论声明多少次，位于几个源文件都表示同一个实体。

```c
typedef char *a;
int b;
int c(int d)
{
    int e;
    int f(int g);
    ...
}
```

如上面代码，在缺省情况下，标识符b、c和f的链接属性都是external，其余的标识符的链接属性都是none。

关键字external和static用于在声明中修改标识符的链接属性。如果某个声明在正常情况下具有external链接属性，在它前面加上static关键字可以使它的链接属性变为internal。如上面的int b;改为static int b;则变量b的链接属性为internal，变成这个源文件私有。

**static只对缺省链接属性为external的声明才有改变链接属性的效果。**

```c
static int i;
int func()
{
    int j;
    extern int k;
    extern int i;
    ...
}
```

extern关键字的规则较为复杂。一般而言，它为一个标识符指定external链接属性，这样就可以访问在其他任何位置定义的这个实体。如上面代码，变量k指定external链接属性，这样函数就可以访问在其他源文件声明的外部变量。当用于具有文件作用域的声明时，这个关键字是可选的，因为文件作用域声明的缺省为external链接属性。如果该关键字用于该标识符的第二次或以后的声明时，它并不会更改由第一次声明所指定的链接属性。如上面代码的变量i，第一声明为static关键字，是内部链接，在函数func内，第二次声明为extern关键字，但不会改变其链接属性，仍然为第一次声明时的链接属性。


## 存储类型
变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。有三个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。

### 静态变量
凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为静态(static)变量。对于这类变量，你无法为它们指定其他存储类型。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。

### 自动变量
在代码块内部声明的变量的缺省存储类型是自动的(automatic)，也就是说它存储于堆栈中，称为自动(auto)变量。在程序执行到声明 自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时，这些自动变量便自行销毁。如果该代码块被数次执行，例如一个函数被反复调用，这些自动变量每次都将重新创建。在代码块再次执行时，这些自动变量在堆栈中所占据的内存位置有可能和原先的位置相同，也可能不同。

对于在代码块内存声明的变量，如果加上关键字static，可以使它的存储类型从自动变为静态。注：修改变量的存储类型不代表修改该变量的作用域。函数的形式参数不能声明为静态。

### 寄存器变量
关键字register可以用于自动变量的声明，提示它们应该存储与机器的硬件寄存器而不是内存中，这类变量称为寄存器变量。但是，编译器不一定理睬register关键字，如果有太多的变量被声明为register，它只会选取前几个实际存储于寄存器，其余的就按普通自动变量处理。寄存器变量的创建和销毁和自动变量相同。


## 初始化
在静态变量初始化中，我们可以把可执行文件想要初始化的值放在当程序执行时变量将会使用的位置。当可执行文件载入到内存时，这个已经保存了正确初始值的位置将赋值给那个变量。如果不显式初始化，静态变量的值为0.

自动变量的初始化需要更多的开销，因为当程序链接时还无法判断自动变量的存储位置。事实上，函数的局部变量在函数的每次调用中可能占据不同的位置。基于这个理由，自动变量没有缺省的初始值，而显式的初始化将在代码块的起始处插入一条隐式的赋值语句。

自动变量显式初始化的这个技巧造成4种后果：
* 自动变量的初始化较之赋值语句并无提高。除了声明为const的变量之外，在声明变量的同时进行初始化和先声明后赋值只有风格之差，并无效率之别。
* 其次，这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数（或代码块）时，每次都将重新初始化。这个行为与静态变量大为不同，后者只是在程序开始执行前初始化一次。
* 这是个优点，由于初始化在运行时执行，因此可以使用任何表达式作为初始值。
* 除非对自动变量进行显式初始化，否则当自动变量创建时，它们的值总是垃圾。


## static关键字
不同的上下文，static关键字的作用不一样。
* 当它用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external到internal，但标识符的作用域和存储类型（代码块外部声明的默认为静态存储类型）不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。
* 当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性（代码块内部声明的默认为none链接属性）和作用域不受影响。


### 作用域、链接属性和存储类型总结
| 变量类型 |   声明位置    | 是否存于堆栈 |     作用域      |                 如果声明为static                 |
| ------- | ------------- | ----------- | --------------- | ----------------------------------------------- |
| 全局    | 所有代码块之外 | 否          | 从声明处到文件尾 | 不允许从其他源文件访问                            |
| 局部    | 代码块起始处   | 是           | 整个代码块      | 变量不存储于堆栈中，它的值在程序整个执行期间一直保持 |
| 形式参数 | 函数头部       | 是          | 整个函数        | 不允许                                           |

