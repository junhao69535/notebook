# 输入和输出函数

## 错误报告
```c
void perror(char const *message);
```
原型位于stdio.h。如果meesage不是NULL并且指向一个非空的字符串，perror函数就打印出这个字符出啊你，后面跟一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息。

**注意，只有当一个库函数失败时，errno才会被设置。当函数成功运行时，errno的值不会被修改。这意味着我们不能通过测试errno的值判断是否有错误发生。反之，只有当被调用的函数提示有错误发生时检查errno的值才有意义。

## 终止运行
```c
void exit(int status);
```
原型位于stdlib.h。status参数返回给操作系统，用于提示程序是否正常完成。这个值和main函数返回的整型状态值相同。

## 标准I/O函数库
这个函数库存在两个主要的缺陷：
* 它是在某台特定类型的机器上实现的，并没有对其他具有不同特性的机器作过多的考虑。移植性差。
* 想修复第一个缺点需要修改库函数，但这会使函数库不再“标准”，程序的可移植性就会降低。

ANSI C函数库中的I/O函数是旧式标准I/O库函数的直接后代，只是这些ANSI版函数作了可移植性和完整性的改进。ANSI C的一个主要优点就是这些修改将通过增加不同函数的方式实现，而不是通过对现存函数进行修改实现。程序的可移植性不会受到影响。

## ANSI I/O概念
头文件stdio.h包含了与ANSI函数库的I/O部分有关的声明，它的名字来源于旧式标准I/O函数库。尽管不包含这个头文件也可以使用某些I/O函数，但绝大部分I/O函数的声明都在这个头文件。

### 流
操作系统负责对不同I/O设备的通信细节，并向程序员提供了一个更为简单和统一的I/O接口。

ANSI C进一步对I/O的概念进行抽象。对C而言，所有的I/O操作只是简单地从程序移进或移出字节。因此，这种字节流便被称为流。个人认为，流就是一个和I/O设备交流的数据结构，如文本流，就以文本形式和I/O设备交流。流是一种抽象。

绝大多数流是完全缓冲的，这意味着“读取”和“写入”实际上是从一块被称为缓冲区的内存区域来回复制数据。用于输出流的缓冲区只有当它写满时才会刷新（也可以强制刷新）到设备或文件中。一次性把写满的缓冲区写入和逐片把程序所产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重写填充缓冲区。

#### 文本流
流分两种类型，文本流和二进制流。文本流的有些特性在不同的系统中可能不同，其中之一就是文本行的最大长度。标准规定至允许254个字符。另一个可能不同的特性时文本行的结束方式，在MS-DOS系统，文本文件约定以一个回车符(''r')和一个换行符('\n')结尾。而Unix系统只是用一个换行符('\n')结尾。库函数向我们隐藏了这些细节，它们会处理好这些细节。

#### 二进制流
二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且完全根据它们从文件或设别读取的形式读入程序中。

### 文件
stdio.h所包含的声明之一就是FILE结构。这是一个数据结构，用于访问一个流。

对于每个ANSI C程序，运行时系统必须提供至少三个流：标准输入、标准输出和标准错误。这些流的名字分别为stdin、stdout、stderr，它们都是在一个指向FILE结构的指针。

### 标准I/O常量
* EOF表示文件尾。
* FOPEN_MAX表示一个程序最多能打开多少个文件。这个值和编译器有关。
* FILENAME_MAX表示编译器支持文件名的最大长度。

## 流I/O总览
文件I/O的一般概况
1. 程序为必须同时处于活动状态的每个文件声明一个指针标量，其类型为FILE *。这个指针指向这个FILE结构，当它储与活动状态时由流使用。
2. 流通过调用fopen函数打开。为了打开一个流，你必须指定需要访问的文件或设备以及它们的访问方式（读、写或读写）。fopen和操作系统验证文件或设备确实存在并初始化FILE结构。
3. 然后，根据需要对该文件进行读取和写入。
4. 最后，调用fclose函数关闭流。关闭一个流可以防止与它相关联的文件被再次访问，保证任何存储于缓冲区的数据被正确地写到文件中，并且释放FILE结构使它可以用于另外的文件。

上面说的是文件流的基本处理。而标准流的I/O更为简单，因为它们不需要打开或关闭。

I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式，都由一组特定的函数对它们进行处理。下表列出了用于每种I/O形式的函数或函数家族。

执行字符、文本行和二进制I/O函数

|   数据类型    |       输入        |       输出        |            描述            |
| ------------- | ----------------- | ----------------- | ------------------------- |
| 字符          | getchar(函数家族） | putchar(函数家族） | 读取（写入）单个字符）      |
| 文本行        | gets(函数家族）    | puts(函数家族)     | 文本行未格式化的输入（输出） |
| 文本行（同上） | scanf(函数家族）   | printf(函数家族)   | 格式化的输入（输出）        |
| 二进制数据     | fread             | fwrite            | 读取（写入）二进制数据      |

函数家族指一组函数中的每个都执行相同的基本任务，只是方式稍有不同。这些函数的区别在于获得输入的来源或输出写入的地方不同，这些变种用于执行下面任务：
1. 只用于stdin或stdout
2. 随作为参数的流使用。
3. 使用内存中的字符串而不是流。

需要一个流参数的函数将接受stdin或stdout作为它的参数。有些函数家族并不具备用于字符串的各种函数，因为使用其他语句或函数来实现相同的结果更为容易。下面表列出每个家族的函数：

输入/输出函数家族

|  家族名  |   目的    | 可用于所有的流 | 只用于stdin和stdout | 内存中的字符串 |
| ------- | --------- | ------------- | ------------------ | ------------- |
| getchar | 字符输入   | fgetc,getc    | getchar            | ①             |
| putchar | 字符输出   | fputc,putc    | putchar            | ①             |
| gets    | 文本行输入 | fgets         | gets               | ②             |
| puts    | 文本行输出 | fputs         | puts               | ②             |
| scanf   | 格式化输入 | fscanf        | scanf              | sscanf        |
| printf  | 格式化输出 | fprintf       | printf             | sprintf       |

① 对指针使用下标引用或间接访问操作从内存获取一个字符（或向内存写入一个字符）。
② 使用strcpy函数从内存读取文本行（或向内存写入文本行）。


## 打开流
```c
FILE *fopen(char const *name, char const *mode);
```
fopen函数打开一个特定的文件，并把一个流和这个文件相关联。两个参数都是字符串，name是打开的文字或设备的名字，mode参数提示流用于只读、只写还是既读又写，类型如下表：

|       | 读取 | 写入 | 添加 |
| ----- | ---- | ---- | ---- |
| 文本   | "r"  | "w"  | "a"  |
| 二进制 | "rb" | "wb" | "ab" |

在mode中添加"a+"表示该文件打开用于更新，并且流即允许读也允许写。

如果fopen函数执行成功，返回一个指向FILE结构的指针，该结构代表这个新创建的流。如果执行失败，返回一个NULL指针，errno会提示问题的性质。

```c
FILE *freopen(char const *filename, char const *mode, FILE *stream);
```
freopen函数用于打开（或重新打开）一个特定的文件流。最后一个参数就是需要打开的流，它可能是一个先前从fopen函数返回的流，也可能是标准流stdin、stdout和stderr。

这个函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流。如果打开失败，返回一个NULL指针。如果打开成功，就会返回第三个参数值。


## 关闭流
```c
int fclose(FILE *f);
```
对于输出流，fclose函数在文件关闭之前刷新缓冲区。如果执行成功，返回零值，否则返回EOF。


## 字符I/O
当一个流被打开以后，它可以用于输入和输出。最简单的形式是字符I/O。

### 输入
字符输入是由getchar函数家族执行，原型如下：
```c
int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);
```

需要操作的流作为参数传递给getc和fgetc，但getchar始终从标准输入读取。每个函数从流中读取下一个字符，然后作为函数返回值返回。如果流中不存在更多的字符，函数就返回常量值EOF。

函数的返回类型是int是因为为了允许函数报告文件的末尾（EOF）。

### 输出
为了把单个字符写入到流中，可以使用putchar函数家族，原型如下：
```c
int fputc(int character, FILE *stream);
int putc(int character, FILE *stream);
int putchar(int character);
```

第一个参数是要被打印的字符。在打印之前，函数把这个整型参数裁剪为一个无符号字符型值。

如果由于任何原型（如写入到一个已被关闭的流）导致函数失败，返回EOF。

### 字符I/O宏
fgetc和fputc都是真正的函数，但getc、putc、getchar、putchar都是通过#include指令定义的宏。宏在执行时间上效率稍高，而函数在程序的长度方面更胜一筹。

### 撤销字符I/O
```c
int ungetc(int character, FILE *stream);
```
ungetc把一个先前读入的字符返回到流中，这样它可以在以后被重新读入。

**撤销字符和流的当前位置有关，如果使用了fseek、fsetpos或rewind函数改变了流的位置，所有退回的字符都将被丢弃。**


## 未格式化的行I/O
未格式化的格式化行I/O的区别：
* 未格式化的I/O简单读取或写入字符串。
* 格式化的I/O则执行数字和其他变量的内部和外部表现形式之间的转换。

gets和puts函数家族用于操作字符串而不是单个字符。原型如下：
```c
char fgets(char *buffer, int buffer_size, FILE *stream);
char gets(char *buffer);

int fputs(char const *buffer, FILE *stream);
int puts(char const *buffer);
```

fgets从指定的stream读取字符并把它们复制到buffer中。当它读取一个换行符并存储到缓冲区之后就不再读取。如果缓冲区内存储的字符达到`buffer_size - 1`个时它也停止读取。在这种情况下，并不会出现数据丢失的情况，因为下一次调用fgets将从流的下一个字符开始读取。在任何一种情况下，一个NUL字节将被添加到缓冲区所存储数据的末尾，使它成为一个字符串。

如果在任何字符读取前就到达了文件末尾，缓冲区就未进行修改，fgets函数返回一个NULL指针。否则，fgets返回它的第一个参数（指向缓冲区的指针）。这个返回值通常只用于检查是否达到了文件尾。

传递给fputs的缓冲区必须包含一个字符串，它的字符将被写入到流中。这个字符串预期以NUL字节结尾，所以这个函数没有一个缓冲区长度参数。这个字符串使逐字写入的：如果它不包含一个换行符，就不会写入换行符。如果它包含了几个换行符，所有的换行符都会被写入。因此，当fgets每次都读取一行时，fputs既可以一次写入一行的一部分，也可以一次写入一行，甚至可以一次写入几行。如果写入时出现错误，fputs返回EOF。否则返回一个写入长度。

**fgets无法把字符串读入到一个小于两个字符的缓冲区，因为其中一个字符需要为NUL字节保留。**

gets和puts默认的流分别为标准输入流和标准输出流。它们几乎和fgets和fputs相同，之所以存在它们是为了允许向后兼容。它们之间的一个主要的功能性区别在于当gets读取一行输入时，它并不再缓存区中存储结尾的换行符。当puts写入一个字符串时，它在字符串写入之后向输出再添加一个换行符。

**另一个区别仅存在于gets，它没有缓冲区长度参数，因此无法判断缓冲区的长度。如果一个长输入行读到一个短输入行，多出来的字符就被写入到缓冲区后面的内存位置，这会导致未定义错误。**


## 格式化行I/O
格式化行I/O并不准确，因为scanf和printf函数家族并不仅限于单行，也可以在行的一部分或多行上上执行I/O操作。

### scanf家族
scanf函数家族原型如下所示。每个原型中的省略号表示一个可变长度的指针列表。从输入转换而来的值逐个存储到这些指针参数所指向的内存位置。

```c
int fscanf(FILE *stream, char const *format, ...);
int scanf(char const *format, ...);
int sscanf(char const *string, char const *format, ...);
```

这些函数都从输入源读取字符并根据format字符串给出的格式代码对它们进行转换。fscanf的输入源就是作为参数给出的流，scanf从标准输入读取，而sscanf则从第一个参数所给出的字符串中读取字符。

当格式化字符串到底末尾或则读取的输入不再匹配格式字符串所指定的类型时，输入就停止。函数返回被转换的输入值的数目，如果在任何输入值被转换之前文件已经到达末尾，返回EOF。

**为了能让这些函数正常运行，指针参数的类型必须对应格式代码的正确类型。如果指针参数的类型是不正确的，那么结果值就会是垃圾，而临近的变量有可能在处理过程中被改写。**

### scanf格式代码
scanf函数家族中的format字符串参数可能包含下列内容：
* 空白字符——它们与输入中的零个或多个空白字符匹配，在处理过程中将被忽略。
* 格式字符——它们指定函数将如何解释接下来的输入字符。
* 其他字符——当任何其他字符出现在格式字符串时，下一个输入字符必须与它匹配，如果匹配，该输入字符随后就被丢弃。如果不匹配，函数就不再读取直接返回。

scanf函数家族的格式代码都以一个百分号开头，后面可以是(1)一个可选的星号，(2)一个可选的宽度，(3)一个可选的限定符，(4)格式代码。星号将使转换后的值被丢弃而不是进行存储。这个技巧可以用于跳过不需要的输入字符。宽度以一个非负的整数给出，它限制将被读取用于转换的输入字符的个数。如未给出宽度，函数就连续读入字符知道遇到输入中的下一个空白字符。限定符用于修改有些格式代码的含义，如下表：

scanf限定符

| 格式码 |       h        |       l       |      L      |
| ----- | -------------- | ------------- | ----------- |
| d,i,n | short          | long          |             |
| o,u,x | unsigned short | unsigned long |             |
| e,f,g |                | double        | long double |

**限定符的目的是为了指定参数的长度。如果整型参数比缺省的整型值更短或更长时，在格式代码中省略限定符就是一个常见的错误。对于浮点类型也是如此。如果省略了限定符，可能会导致一个较长变量只有部分被初始化，或者一个较短变量的临近变量也被修改。**

scanf格式吗

|  代码   |    参数    |                                                                                                                                                                                              含义                                                                                                                                                                                              |
| ------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| c       | char *     | 读取和存储单个字符。前导的空白字符并不跳过。如果给出宽度，就读取和存储这个数目的字符。字符后面不会添加一个NUL字节。参数必须指向一个足够大的字符数组                                                                                                                                                                                                                                                         |
| i、d    | int *      | 一个可选的有符号整数被转换。d把输入解释为十进制数；i根据它的第一个字符决定值的基数，就像整型字面值常量的表示形式一样。                                                                                                                                                                                                                                                                                   |
| u、o、x | unsigned * | 一个可选的有符号整数被转换，但它按照无符号数存储。如果使用u，值被解释为十进制数；如果使用o，值被解释为八进制数；如果使用x，值被解释为十六进制数。X和x同义。                                                                                                                                                                                                                                                 |
| e、f、g | float *    | 期待一个浮点值。它的形式必须像一个浮点型字面值常量，但小数点并非必须。E和G分别与e和g同义。                                                                                                                                                                                                                                                                                                             |
| s       | char *     | 读取一串非空白字符。参数必须指向一个足够大的字符数组。当发现空白时输入就停止，字符串后面会自动添加NUL字节。                                                                                                                                                                                                                                                                                             |
| [xxx]   | char *     | 根据给定组合的字符从输入中读取一串字符。参数必须指向一个足够大的字符数组。当遇到第一个不再给定组合中出现的字符时，输入就停止。字符串后面会自动加上NUL字节。代码%[abc]表示字符组合a、b和c。如果列表中以^字符开头，表示字符组合时所列出的字符的补集，所以%[^abc]表示字符组合为a、b、c之外的所有字符。右边括号也可以出现在字符列表中，但它必须是列表的第一个字符。至于横杠是否用于指定某个范围的字符（例如%[a-z]），则因编译器而异。 |
| p       | void *     | 输入预期为一串字符，诸如那些由printf函数%p格式代码所产生的输出。它的转换方式因编译器而异，但转换结果将和按照上面描述的进行打印所产生的值是相同的。                                                                                                                                                                                                                                                         |
| n       | int *      | 到目前为止通过这个scanf函数的调用从输入读取的字符数被返回。%n转换的字符并不计算在scanf函数的返回值之内。它本身并不消耗任何输入。                                                                                                                                                                                                                                                                         |
| %       | 无         | 这个代码与输入中的一个%相匹配，该%符号将被丢弃。                                                                                                                                                                                                                                                                                                                                                   |


### printf家族
printf函数家族用于创建格式化输出。这个家族共有三个函数：fprintf、printf和sprintf。原型如下：
```c
int fprintf(FILE *stream, char const *format, ...);
int printf(char const *format, ...);
int sprintf(char *buffer, char const *format, ...);
```

**sprintf是一个潜在的错误根源。缓冲区的大小并不是spirntf函数的一个参数，所以如果输出结果很长溢出缓冲区时，就可能改写缓冲区后面内存位置中的数据。**

printf格式代码由一个百分号开头，后面跟(1)零个或多个标志符号，用于修改有些转换的执行方式，(2)一个可选的最小字段宽度，(3)一个可选的精度，(4)一个可选的修改符，(5)转换类型。

printf格式代码

|    代码    |     参数     |                                                    含义                                                     |
| --------- | ------------ | ----------------------------------------------------------------------------------------------------------- |
| c         | int          | 参数被裁剪为unsigned char并作为字符进行打印。                                                                  |
| d、i       | int          | 参数作为一个十进制数打印。如果给出了精度而且值的位数少于精度位度，前面就用0补充。                                  |
| u、o、x，X | unsigned int | 参数作为一个无符号值打印，u使用十进制，o使用八进制，x或X使用十六进制，两个的区别是x约定使用abcdef，而X约定使用ABCDEF |
| e、E       | double       | 参数根据指数形式打印。如6.023000e23使用代码e，6.023000E23使用代码E。小数点后面的位数由精度字段决定，缺省值是6。     |
| f         | double       | 参数按照常规的浮点格式打印。精度字段决定小数点后面的位数，缺省值为6。                                             |
| g、G       | double       | 参数以%f或%e（如G则%E）的格式打印，取决于它的值。如果指数大于等于-4但小于精度字段就使用%f格式，否则使用指数格式。    |
| s         | char *       | 打印一个字符串。                                                                                              |
| p         | void *       | 指针值被转换为一串因编译器而异的可打印字符。这个代码主要是和scanf中的%p代码组合使用。                              |
| n         | int *        | 到目前为止函数所产生的输出字符数目将被保存到对应的参数中。                                                       |
| %         | 无           | 打印一个%字符。                                                                                              |

printf格式标志

| 标志 |                                                                                                    含义                                                                                                     |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -    | 值在字段中左对齐，缺省是右对齐                                                                                                                                                                                |
| 0    | 当数值为右对齐时，缺省是使用空格填充值左边未使用的列。这个标志表示用零来填充，它可用于d,i,u,o,x,X,e,E,f,g和G代码。使用d,i,u,o,x和X代码时，如果给出精度字段，零标志就被忽略。如果格式代码中出现了符号标志，零标志也没有效果。 |
| +    | 当用于一个格式化某个有符号值的代码时，如果值为非负，正好标志就会给它加上一个正号。如果该值为负，就像往常一样显式一个负号。缺省不显式正号。                                                                              |
| 空格 | 只用于转换有符号值的代码。当值为非负时，这个标志把一个空格添加到它的开始位置。注意这个标志和正号标志时相互排斥的，如果两个同时给出，空格标志便被忽略。                                                                   |
| #    | 选择某些代码的另一种转换形式。                                                                                                                                                                                |

其他有关printf的请参考网络。


## 二进制I/O
把数据写到文件效率最高的方法是用二进制形式写入。但二进制数据难以阅读，所以只有当数据将被两一个程序按顺序读取时才能使用。

fread函数用于读取二进制数据，fwrite函数用于写入二进制数据，原型如下：
```c
size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream);
```

buffer是一个指向用于保存数据的内存位置的指针，size是缓冲区中每个元素的字节数，count是读取或写入的元素数。函数的返回值是实际读取或写入的元素（并非字节）数目。如果写入过程中遇到了文件尾或输出过程出现错误，这个值可能比请求的元素数目要小。


## 刷新和定位函数
fflush函数，强制刷新输出缓冲区进行物理写入，不管缓冲区是否已满。原型如下：
```c
int fflush(FILE *stream);
```

C支持随机访问I/O。随机访问是通过在读取或写入前定位到文件中需要的位置来实现的。有两个函数用于执行这个操作，原型如下：
```c
int ftell(FILE *stream);
int fseek(FILE *stream, long offset, int from);
```

ftell函数返回流的当前位置，即下一个读取或写入将要开始的位置距离文件起始位置的偏移量。在二进制流中，这个值就是当前位置距离文件起始位置之间的字节数。

fseek函数能在一个流中定位。第二个和第三个参数表示文件中需要定位的位置。第三个参数可以是以下宏：

fseek参数

| 如果from是 |                                 将定位到                                  |
| --------- | ------------------------------------------------------------------------ |
| SEEK_SET  | 从流的起始位置起offset个字节，offset必须是一个非负值                         |
| SEEK_CUR  | 从流的当前位置起offset个字节，offset的值可正可负                            |
| SEEK_END  | 从流的尾部位置起offset个字节，offset可正可负，如果是正值，将定位到文件尾的后面 |

在二进制流中，SEEK_END进行定位可能不被支持，应该避免。在文本流中，如果from是SEEK_CUR或SEEK_END，offset必须是零。如果from是SEEK_SET，offset必须是同一个流中以前调用ftell所返回的值。之所以存在这些限制，部分原因是文本流所执行的行末字符映射。由于这种映射的存在，文本文件的字节数可能和程序写入的字节数不同。

用fseek改变一个流的位置会带来三个副作用：
* 行末指示符被清除。
* 如果在fseek之前使用ungetc把一个字符返回到流中，那么这个被退回的字符被丢弃，因为在定位操作以后，它不再是”下一个字符“。
* 定位允许从写入模式切换到读取模式，或者回到打开的流以便更新。

另外还有三个额外的函数，用一些限制更严的方式执行相同的任务。原型如下：
```c
void rewind(FILE *stream);
int fgetopt(FILE *stream, fpos_t *position);
int fsetpot(FILE *stream, fpos_t const *position);
```

rewind函数将读/写指针设置回指定流的起始位置。它同时清除流的错误提示标志。fgetpos和fsetops函数分别是ftell和fseek函数的替代方案。主要区别在于这对函数接收一个指向fpos_t的指针作为参数。fgetops在这个位置存储文件的当前位置，fsetopt把文件位置设置为存储在这个位置的值。


## 改变缓冲方式
在流上执行缓冲方式有时并不合适，下面两个函数可以用于对缓冲方式进行修改。这两个函数只有当指定的流被打开但还没有在它上面执行任何其他操作前才能被调用。
```c
void setbuf(FILE *stream, char *buf);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```

setbuf设置了另外一个数组，用于对流进行缓冲。这个数组的字符长度必须为BUFSIZ（在stdio.h中定义）。为一个流自行指定缓冲区可以防止I/O函数库为它动态分配一个缓冲区。如果用一个NULL参数调用这个函数，setbuf函数将关闭流的所有缓冲方式。

**为流缓冲区使用一个自动数组是很危险的。如果在流关闭之前，程序的执行流离开了数组声明所在的代码块，流就会继续使用这块内存，但此是它可能已经分配给了其他函数另作它用。**

setvbuf函数更为通用。mode参数用于指定缓冲的类型。_IOFBF指定一个完全缓冲的流，_IONBF指定一个不缓冲的流。_IOLBF指定一个行缓冲的流。行缓冲就是每当一个换行符写入到缓冲区时，缓冲区便进行刷新。